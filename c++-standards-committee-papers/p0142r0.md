---
description: 'http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0142r0.pdf'
---

# A Module System for C++ \(Revision 4\)

## 1 Introduction

The lack of direct language support for componentization of C++ libraries and programs, combined with increasing use of templates, has led to serious impediments to compile-time scalability, and programmer productivity. It is the source of lackluster build performance and poor integration with cloud and distributed build systems. Furthermore, the heavy-reliance on header file inclusion \(i.e. copy-andpaste from compilers’ perspective\) and macros stifle flowering of C++ developer tools in increasingly semantics-aware development environments.

Responding to mounting requests from application programmers, library developers, tool builders alike, this report proposes a module system for C++ with a handful of clearly articulated goals. The proposal is informed by the current state of the art regarding module systems in contemporary programming languages, past suggestions \[4, 6\], experiments such as Clang’s \[2, 5\], ongoing implementation in the Microsoft C++ compiler, and practical constraints specific to C++ ecosystem, deployment, and use. The design is minimalist; yet, it aims for a handful of fundamental goals

1. componentization;
2. isolation from macros;
3. scalable build;
4. support for modern semantics-aware developer tools

Furthermore, the proposal reduces opportunities for violations of the One Definition Rule \(ODR\), and increases practical type-safe linking. An implementation of these suggestions is ongoing in the Microsoft C++ compiler.

由于缺乏对C++库和程序的组件化的直接语言支持，加上越来越多地使用模板，导致了编译时可伸缩性和程序员生产力的严重障碍。它是构建性能低下、难以与云和布式构建系统集成的根源。此外，对头文件包含（即从编译器的角度复制粘贴）和宏的严重依赖，C++开发工具难以在越来越多语义感知的开发环境中有所作为。

为了响应来自应用程序程序员、库开发人员和工具构建人员的大量请求，本报告提出了一个C++模块系统，其中有一些明确的目标。这个建议是根据当前编程语言中模块系统的现状、过去的建议\[4, 6\]、实验（如Clang\[2, 5\]）、Microsoft C++编译器中正在进行的实现以及C++生态系统、部署和使用的实际约束而提出的。设计极简，然而，它瞄准了如下几个基本目标

1. 组件化； 
2. 隔离宏； 
3. 可伸缩的构建；
4. 支持现代语义感知的开发工具

此外，该建议减少了违反单一定义规则（ODR）的机会，并增加了实用的类型安全的链接。这些建议的实现正在Microsoft C++编译器中进行。

## 2 Changers from Previous Revisions

### 2.1 Changes from N4465

Incorporate feedback from the Core Working Group \(CWG\), mostly clarifying terminology and design points:

* addition of a new linkage: module linkage
* allow block-scope `extern` declaration to match previous declarations in current module unit
* strong module ownership is deferred

结合核心工作小组（CWG）的反馈意见，主要澄清术语和设计要点：

1. 添加了一个新的链接方式：模块链接
2. 允许块作用域`extern`声明与当前模块单元中的先前声明（previous declarations）相匹配
3. 强模块所有权被延迟

## 3 The Problems

The primary issue we face when trying to scale compilation of C++ libraries and programs to billions of lines of code is how C++ programmers author software components, compose, and consume them.

在试图将C++库和程序的编译扩展到数十亿行代码时，我们面临的主要问题是C++程序员如何编写软件组件，以及如何组成和使用它们。

### 3.1 The Existing Compilation and Linking Model

C++ inherited its linking model from C’s notion of independent compilation. In that model, a program is composed of several translation units that are processed independently of each other. That is, each translation unit is processed with no knowledge or regard to any other translation units it might be composed with in an eventual program. This obviously poses inter-translation units communication and coherence challenges. The communication problem is resolved via the notion of name linkage: a translation unit can reference, by name, an entity defined in another translation – provided the entity’s name is external. All that the consuming translation unit needs to do \(because it is translated independently and with no knowledge of that entity’s defining translation unit\) is to brandish a “matching” declaration for the referenced entity. The following example illustrates the concept. Consider the program composed of the translation units 1.cc and 2.cc:

C++从C的独立编译概念继承了它的链接模型。在该模型中，程序由几个独立处理的编译单元组成。也就是说，每个编译单元都是在不了解或不考虑任何其他编译单元的情况下进行处理的，这些编译单元可能在最终的程序中被组合到一起。这显然给编译单位之间的沟通和一致性带来了挑战。通过名称链接的概念解决了通信问题：编译单元可以通过名称引用另一个编译中定义的实体，只要实体的名称是外部的。消费编译单元所需要做的（因为它是独立编译的，并且不知道该实体定义的编译单元）就是为被引用的实体显露出一个匹配的声明。下面的例子说明了这个概念。考虑由编译单元组成的程序1.cc和2.cc

{% code-tabs %}
{% code-tabs-item title="1.cc \(producer of quant\)" %}
```cpp
int quant(int x, int y) {
    return x*x + y*y;
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

{% code-tabs %}
{% code-tabs-item title="2.cc \(consumer of quant\)" %}
```cpp
extern int quant(int, int);
int main() {
    return quant(3, 4);
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

The program is well-formed and the calls to quant \(in 2.cc\) is resolved to the definition in translation unit 1.cc. Please note that none of the translation units mentions anything about each other: 2.cc \(the consumer of the definition of `quant`\) does not say anything about which translation unit is supposed to provide the definition of quant. In particular, the program composed of the translation units 2.cc and 3.cc, defined as follows

该程序正确，并且对quant（2.cc）的调用被解析为编译单元1.cc中的定义。 请注意，没有一个编译单元提到彼此之间的任何内容：2.cc（定义`quant`的消费者）没有说明哪个编译单元应该提供`quant`的定义。 特别地，由编译单元2.cc和3.cc组成的程序，其定义如下

{% code-tabs %}
{% code-tabs-item title="3.cc \(another producer of quant\)" %}
```cpp
#include <stdlib.h>
int quant(int x, int y) {
    return abs(x) + abs(y);
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

is also well-formed. This linking model, whereby translation units do not take explicit dependencies and external names are resolved to whatever provides them, is the bedrock of both C and C++ linking model. It is effective, but low-level and brittle. It also underscores the problem of coherency across translation units with declarations of entities with external linkage; in another words it poses continuing vexing type-safe linking challenges \[1, §7.2c\].

同样是正确的。这个链接模型是C和C++链接模型的基础，在这个模型中，编译单元不接受显式依赖关系，外部名称解析并不在意是哪一个对象负责提供了它们。它是有效的，但同时也是低级别的和脆弱的。它还凸显了这些具有外部声明的编译单元之间的一致性问题；换句话说，它带来了一个让我们持续头疼的类型安全的链接挑战 \[1, §7.2c\]。

### 3.2 Header Files and Macros

The conventional and most popular C++ software organization practice rests upon a more than four decades old linking technology \(§3.1\) and a copy-and-paste discipline. Components communicate via sets of so-called external names designating externally visible entry points. To minimize risks of errors of various sorts, these names are typically declared in header files, conventionally placed in backing storage of the hosting environment filesystem. A given component uses a name defined in another component by including the appropriate header file via the preprocessor directive `#include`. This constitutes the basic information sharing protocol between producers and consumers of entities with external names. However, from the compiler’s point of view, the content of the header file is to be textually copied into the including translation unit. It is a very simple engineering technology that has served the C and C++ community for over forty years. Yet, over the past seventeen years, this source file inclusion model has increasingly revealed itself to be ill-suited for modern C++ in large scale programming and modern development environments.

传统的和最流行的C++软件组织实践依赖于40多年前的链接技术（§3.1）和复制粘贴规则。组件通过指定外部可见入口点的所谓外部名称集进行通信。为了减少各种错误的风险，这些名称通常在头文件中声明，通常放在宿主环境文件系统的备份存储中。给定的组件使用另一个组件中定义的名称，通过预处理器指令`#include`包含适当的头文件。这构成了具有外部名称的实体的生产者和消费者之间的基本信息共享协议。但是，从编译器的角度来看，头文件的内容将被文本复制到包含了该头文件的编译单元。它是一种非常简单的工程技术，已经为C和C++社区服务了40多年。然而，在过去的17年里，这个源文件包含模型越来越多地显示出它不适合大规模编程和现代开发环境中的现代C++。

The header file subterfuge was invented as a device to mitigate the coherency problem across translation units. When used with care, it gives the illusion that there is only one “true source” of declaration for a given entity. However, it has several frequent practical failure points. It commonly leads to inefficient use of computing resources; it is a fertile source of bugs and griefs, some of which have been known since the discovery of the preprocessor. The contents of header files are vulnerable to macros and the basic mechanism of textual inclusion forces a compiler to process the same declarations over and and over in every translation unit that includes their header files. For most “C-like” declarations, that is probably tolerable. However, with modern C++, header files contain lot of executable codes. The scheme scales very poorly. Furthermore, because the preprocessor is largely independent of the core language, it is impossible for a tool to understand \(even grammatically\) source code in header files without knowing the set of macros and configurations that a source file including the header file will activate. It is regrettably far too easy and far too common to under-appreciate how much macros are \(and have been\) stifling development of semantics-aware programming tools and how much of drag they constitute for C++, compared to alternatives.

头文件的诡计是为了减轻编译单元之间的相干问题而发明的。当小心使用时，它给人一种错觉，即给定实体只有一个真正的声明源。然而，它有不少常见的实用中的问题点。它通常导致计算资源的低效使用；它是bug和编译事故的沃土，其中一些自预处理器被发现以来就为人所知。头文件的内容容易受到宏的破坏，而文本包含的基本机制迫使编译器在包含头文件的每个编译单元中反复处理相同的声明。对于大多数类似c的声明，这可能是可以容忍的。然而，在现代C++中，头文件包含很多可执行代码。整个体系的规模令人发指。此外，由于预处理器在很大程度上独立于核心语言，如果不知道包括头文件在内的源文件将激活的宏和配置选项，工具就不可能理解头文件中的源代码（甚至在语法上也是如此）。遗憾的是，它太过简单，也太过普通，以至于不能评估宏是如何（并且一直）抑制语义感知编程工具的开发，以及它们为C++带来的包袱（与其他编程工具相比）。

### 3.3 The One Definition Rule

C++ is built around the principle that any entity in a well-formed program is defined exactly once. Unfortunately, the exact formulation of this rule isn’t that simple, primarily because of unfortunate but unavoidable consequences of the copy-and-paste technology implied by the preprocessor directive \#include. The outcome is that the arcane formal rules are variously interpreted by implementers \(violation of the ODR results in undefined behavior\), doubt, uncertainty, and sometimes outright willful disregard, from library writers and application programmers. Quoting Bjarne Stroustrup in the EWG reflector message c++std-lib:

> _“Every word in the C and C++ definitions about ‘ODR’ are there to work around the fact that we cannot identity the one true definition and have to compare definitions instead.”_

C++是建立在这样一个原则之上的：在一个格式良好的程序中，任何实体都只定义一次。不幸的是，这个规则的精确表述并不那么简单，主要是因为预处理器指令\#include隐含的复制粘贴技术带来了不幸且不可避免的后果。结果是，那些晦涩难懂的正式规则被实现人员（违反ODR会导致未定义的行为）、怀疑、不确定，有时甚至是来自库作者和应用程序程序员的完全故意的漠视。引用Bjarne Stroustrup在EWG反映给c++std-lib的话：

> _“关于ODR的C和C++定义中的每个字都在回避这样一个事实，即我们不能识别一个真正的定义，而是必须去比较定义。”_

Having a single, authoritative place that provides the declaration \(and definition\) of an entity reduces the risks of declaration mismatches going undetected, and improvements to type safe linkage.

拥有一个提供实体声明（和定义）的独立的、权威的位置，可以减少声明不匹配而未被检测到的风险，并改进类型安全的链接。

## 4 Goals and Principles

The design described in these pages aims at supporting sound software engineering practices for large scale programming \(e.g. componentization\), scalable uses of development resources \(e.g. build throughput, build frameworks\), semantics-aware development tools \(e.g. code analysis\), etc.

这里描述的设计旨在为大规模编程（例如组件化）、可伸缩的开发资源（例如构建吞吐量、构建框架）、语义感知的开发工具（例如代码分析）等支持良好的软件工程实践。

### 4.1 The Preprocessor

While many of the problems with the existing copy-and-paste methodology can be directly tied to the nature of the preprocessor, this proposal suggests neither its eradication nor improvements of it. Rather, the module system is designed to co-exist with and to minimize reliance on the preprocessor. We believe that the preprocessor has been around for far too long and supports far too many creative usage for its eradication to be realistic in the short term. Past experience suggests that any improvements to the preprocessor \(for modularization\) is likely to be judged either not enough or going too far. We concluded that whatever the problems are with the preprocessor, any modification at that level to support modularization is likely to add to them without fundamentally moving the needle in the right direction.

虽然现有复制-粘贴方法的许多问题可以直接与预处理器的性质联系在一起，但本提案既不建议消除它，也不建议改进它。相反，模块系统的设计是为了与预处理器共存并尽量减少对预处理器的依赖。我们相信预处理器已经存在太久了，并且支持了太多的创造性使用，使得对其的改动在短期内无法实现。过去的经验表明，对预处理器（用于模块化）的任何改进都可能被认为不够或做得太过。我们得出的结论是，无论预处理器存在什么问题，在这个级别上进行任何支持模块化的修改都可能会增加这些问题，而不会正确的从根本上解决问题。

A central tenet of this proposal is that a module system for C++ has to be an evolution of the conventional compilation model. The immediate consequence is that it has to inter-operate with the existing source file inclusion model while solving the significant problems and minimizing those that can’t be completely solved.

本提案的核心原则是C++模块系统必须是传统编译模型的改进。直接的结果是，它必须与现有的源文件包含模型相交互，同时解决重要的问题，并最小化那些不能完全解决的问题。

### 4.2 Componentization and Interface

For effective componentization, we desire direct linguistic support for designating a collection of related translation units, a module, with well-defined set of entry points \(external names\) called the module’s interface. The \(complete\) interface should be available to any consumer of the module, and a module can be consumed only through its interface. Usually, a module contains many more entities than those listed in its exported declarations. Only entities explicitly listed by the module interface are available for consumption \(by name\) outside the module. A translation unit constituent of a module is henceforth called a module unit. A module should have a symbolic name expressible in the language, so that it can be used by importing translation unit \(consumer\) to establish an explicit symbolic dependency.

为了有效的组件化，我们需要直接的语言支持来指定一组相关的编译单元，一个模块，带有一组定义良好的入口点（外部名称），称为模块接口。模块的任何使用者都可以使用（完整的）接口，并且模块只能通过模块接口被使用。通常，模块包含的实体比导出声明中列出的要多得多。只有模块接口显式列出的实体可以在模块外部使用（按名称）。模块的编译单元组成部分从此称为模块单元。模块应该具有语言中可表达的符号名称，以便通过导入编译单元（使用者）来建立显式符号依赖关系。

![](../.gitbook/assets/image%20%281%29.png)

### 4.3 Scoping Abstraction

One of the primary goals of a module system for C++ is to support structuring software components at large scale. Consequently, we do not view a module as a minimal abstraction unit such as a class or a namespace. In fact, it is highly desirable that a C++ module system, given existing C++ codes and problems, does not come equipped with new sets of name lookup rules. Indeed, C++ already has at least seven scoping abstraction mechanisms along with more than half-dozen sets of complex regulations about name lookup. We should aim at a module system that does not add to that expansive name interpretation text corpus. We suspect that a module system not needing new name lookup rules is likely to facilitate mass-conversion of existing codes to modular form. Surely, if we were to design C++ from scratch, with no backward compatibility concerns or existing massive codes to cater to, the design choices would be remarkably different. But we do not have that luxury.

C++模块系统的主要目标之一是支持大规模结构化软件组件。因此，我们不将模块视为最小的抽象单元，例如类或名称空间。实际上，考虑到现有的C++代码和问题，我们非常希望C++模块系统不配备新的名称查找规则集。实际上，C++已经有了至少7个范围抽象机制，以及超过6套关于名称查找的复杂规则。我们应该针对的是一个模块系统，它不会增加扩展的名称解释文本语料库。我们怀疑不需要新的名称查找规则的模块系统可能会促进现有代码向模块化形式的大规模转换。当然，如果我们从头开始设计C++，不考虑向后兼容性问题，也不考虑现有的大量代码，那么设计的选择将会非常不同。但我们没有那种奢侈的从容。

### 4.4 Separation

A key property we require from a module system for C++ is separation: a module unit acts semantically as if it is the result of fully processing a translation unit from translation phases 1 through 7 as formally defined by the C++ standards \[3, Clause 2\]. In particular, a module unit should be immune to macros and any preprocessor directives in effect in the translation unit in which it is imported. Conversely, macros and preprocessor directives in a module unit should have no effect on the translation units that import it.

我们的C++模块系统中所需要的一个关键属性是**分离**：模块单元的语义行为就好像它是从C++标准 \[3, Clause 2\] 正式定义的编译阶段1到7完全处理编译单元的结果一样。特别地，模块单元应该对宏和导入它的编译单元中有效的任何预处理器指令免疫。同时，模块单元中的宏和预处理器指令应该对导入它的转换单元没有影响。

Similarly, a declaration in an importing module unit should have no effect –in general– on the result of overload resolution \(or the result of name lookup during the first phase of processing a template definition\) performed in the imported module and its module units. That is, module units and modules should be thought of as “fully backed” translation units.

类似地，导入模块单元中的声明对导入模块及其模块单元中执行的重载解析（或在处理模板定义的第一阶段中查找名称的结果）的结果没有任何影响。也就是说，模块单元和模块应该被认为是“完全支持”的编译单元。

A corollary of the separation principle is that the order of consecutive import declarations should be irrelevant. This enables a C++ implementation to separately translate individual modules, cache the results, and reuse them; therefore potentially bringing significant build time improvements. This contrasts with the current source file inclusion model that generally requires re-processing of the same program text over and over.

分离原则的一个推论是，连续导入声明的顺序是不重要的。这使得C++实现能够分别转换单个模块、缓存结果并重用它们。因此，这很可能带来显著的构建时间的改进。这与当前的源文件包含模型形成对比，后者通常需要反复处理相同的程序文本。

### 4.5 Composability

Another key primary purpose of a module system is to allow independent components to be developed independently \(usually by distinct individuals or organizations\) and combined seamlessly to build programs. In particular, we want the ability to compose independent modules that do not export the same symbols in a program without worrying about possible duplicate definition clashes from their defining modules \(see §5.4.\) Therefore, a corollary of the composability requirement is that of ownership and visibility of declarations: a module owns declarations it contains, and its non-exported entities have no relationship with entities from other modules. This is the strong module ownership model. At the Spring 2015 Meeting in Lenexa, there were concerns that the strong module ownership may require ABI breakage. Consequently, the Evolution Working Group \(EWG\) has adopted a weaker version, called the weak module ownership model: Only non-exported entities are owned by the modules containing their declarations; it is ill-formed \(but no diagnostic required\) for a program to contain two modules exporting two entities of the same kind/type with the same name from the same namespace.

模块系统的另一个主要目的是允许独立的组件独立开发（通常由不同的个人或组织开发），并无缝地结合起来构建程序。特别是，我们希望能够组成独立的模块，这些模块不会在程序中导出相同的符号，而不用担心它们定义的模块可能出现重复定义冲突（参见5.4）。因此，可组合性需求的一个推论是声明的所有权和可见性：模块拥有它所包含的声明，而它的非导出实体与来自其他模块的实体没有关系。这是**强模块所有权模型**。在莱内克萨（Lenexa）召开的2015年春季会议上，有人担心强模块所有权可能会导致ABI断裂。因此，Evolution Working Group（EWG）采用了一个较弱的版本，称为**弱模块所有权模型**：只有非导出实体由包含其声明的模块所有；对于一个程序来说，若包含两个导出了相同命名空间中相同名称且具有相同样式/类型的实体的模块，则是ill-formed（但no diagnostic required）。

Operationally, there are various ways an implementation may achieve this effect. E.g. decorating an entity’s linkage name with its owning module’s name, two-level linking namespace, etc. However, we believe that the notion of linkage should not be elevated above where it belongs, and existing implementations have access to far more elaborate linkage mechanisms than formally acknowledged and acknowledgeable by the C++ standards.

在操作上，可以有多种方式实现这种效果。如修饰一个实体的链接名称，让其拥有模块的名称，二级链接名称空间，等等。但是我们认为，链接的概念不应该高于其所属的位置，并且现有的实现可以访问比C++标准正式承认和可承认的更复杂的链接机制。

### 4.6 Coexistence with Header File

In an ideal world with modules, the usage of the time-honored header files should be rare, if not inexistent. However, realistically we must plan for a transitional path where programs involve components written today in the source-file-inclusion model, and new module-based components or existing components converted to use modules. Furthermore, conversion from heavy macro-based header files are likely to combine parts that are safely modularized with old-style macro interfaces – until the world has completely moved to pure module systems and the preprocessor has vanished from the surface of planet Earth, Solar System.

在一个具有模块的理想世界中，使用历史悠久的头文件应该很少见，如果不是不存在的话。但实际上，我们必须规划一个过渡的过程，这个阶段的程序会使用到今天在源文件包含模型中编写的组件，以及新的基于模块的组件或转换为使用模块的现有组件。此外，由大量的基于宏的头文件转换而来，可能会将已安全模块化的部分与老式宏接口组合在一起 —— 直到整个世界完全转向纯模块系统，而预处理器已经从这个世界消失。

We acknowledge that the principle of coexistence with source file inclusion does pose significant constraints and brings complications into the design space, e.g. with respect to the ODR.

我们承认与源文件包含共存的原则确实对设计造成了很大的限制，并带来了复杂性，例如ODR。

### 4.7 Runtime Performance

Moving an existing code to a brave new module world, or writing new codes with modules, should not in any way degrade its runtime performance characteristics. In particular, we do not seek a module system requiring a compiler to perform automatic “boxing” of object representation \(exposed in class private members\) –in attempts to reducing re-compilation– via opaque data pointers a la \` pImpl idiom.

将现有代码迁移到一个全新的模块世界，或者使用模块编写新的代码，都不应该以任何方式降低其运行时性能特征。特别地，我们不寻求一个模块系统，它要求编译器执行对象表示的自动“装箱”（在类私有成员中公开）—— 试图通过不透明的数据指针（pImpl风格惯用法）来减少重新编译。

## 5 Design Choices

The principles and goals just outlined confine us to parts of the module system design space. We have to make further design decisions. Ideally, it should be easy to transform an existing program \#includeing header files to consume modules, e.g.:

刚才概述的原则和目标只局限于模块系统设计空间的一部分。我们必须做出进一步的设计决策。理想情况下，转换现有程序`#include`头文件来使用模块应该很容易，例如：

```cpp
import std.vector;   // #include <vector>
import std.string;   // #include <string>
import std.iostream; // #include <iostream>
import std.iterator; // #include <iterator>

int main() {
    using namespace std;
    vector<string> v = {
        "Socrates", "Plato", "Descartes", "Kant", "Bacon"
    };
    copy(begin(v), end(v), ostream_iterator<string>(cout, "\n"));
}
```

That is, it should be a matter of mechanical replacement of header files with corresponding module import declarations and nothing else.

也就是说，它应该是用相应的模块导入声明机械地替换头文件，而不是什么其他的东西。

### 5.1 Module Declaration

The first design decision to make is whether it is necessary for a translation unit to declare itself as a module unit, or if the fact that it is a module unit is the result of some compiler invocation command line switches or some external configuration files.

首先要做的设计决策是编译单元是否有必要声明自己为模块单元，或者它是否是模块单元，是由某些编译器命令或一些外部配置文件来决定的。

Given that a module unit is expected to possess a strong ownership semantics, unlike a mere preprocessing unit, it is important that the rules of interpretation are reflected syntactically as opposed to being guessed from the translation environment, the build environment, or implementation-defined command line invocation switches. Consequently, we propose that a module unit be introduced by a declaration:

考虑到模块单元被期望具有强大的所有权语义，与仅仅是预处理单元不同，重要的是其解析规则应该在语法上反映出来，而不是从编译环境、构建环境或实现定义的命令行调用中猜测出来。因此，我们建议通过声明引入一个模块单元：

> module _module-name_ ;

This declaration means that subsequent declarations in the current translation unit are part of the module nominated by module-name. For simplicity, there can be at most one module declaration per translation unit. In a previous design, we required the module declaration to be the first declaration in a module unit; that requirement wasn’t necessary \(as acknowledged at the time\). To support gradual transition from the current compilation model to a world with module we allow toplevel declarations to preceed the module declaration in a module unit. Such declarations do not belong to the nominated module. They belong to the global module \(§5.7\).

此声明意味着**当前转换单元中的后续声明是由模块名指定的模块的一部分**。为了简单起见，每个编译单元最多可以有一个模块声明。在以前的设计中，我们要求模块声明是模块单元中的第一个声明；这个要求并不是必须的（正如当时所承认的那样）。为了支持从当前编译模型逐步过渡到具有模块的世界，我们允许顶层声明先于模块单元中的模块声明。这样的声明不属于指定的模块。它们**属于全局模块**（§5.7）。

{% hint style="warning" %}
**Rule 1** _A translation unit may contain at most one module declaration. The resulting translation unit is referred to as a_ module unit.

**规则1** _编译单元最多可包含一个模块声明。生成的编译单元称为_模块单元。
{% endhint %}

{% hint style="info" %}
**Note:** A module can span several module units — all of which must declare the module they belong to. Like most declarations in C++, it may be necessary to allow attributes on module declarations.

**注：**一个模块可以跨越几个模块单元 —— 所有单元都必须声明它们所属的模块。与C++中的大多数声明一样，可能需要在模块声明上允许属性。
{% endhint %}

#### 5.1.1 Module Names and Filenames

Having decided on the necessity to have a module declaration, the next question is whether the module-name should have any relationship at all with the filename of the source file containing the module unit. We believe that prescribing any such relationship will be too rigid, impractical compared to the flexibility offered today by the source file inclusion model – see examples in §3.1.

在决定有必要进行模块声明之后，下一个问题是模块名是否应该与包含模块单元的源文件名有关系。我们相信限定任何这样的关系，其灵活性相比今天提供的源文件包含模型，都会是过于僵化，不切实际的 —— 参考§3.1中的例子。

We propose a hierarchical naming scheme for the name space of module-name in support of submodules, see §5.5.

我们在模块名称的命名空间中提出了一种基于层级的命名方案，用于支持子模块，参考§5.5。 ❓ 

### 5.2 Module Interface

It is desirable, from composability perspective, that the language has direct support for expressing a module interface separately from its implementation. This raises at least two questions:

从可组合性的角度来看，我们希望该语言能够直接支持将模块接口与其实现分离开来。这至少提出了两个问题：

1. Should a module interface declaration be required in a source file distinct from the file that contains its implementation? 源文件中是否需要模块接口声明，以区别于包含其实现的文件？
2. Should both the interface and implementation of a module be contained in a single source file? 模块的接口和实现都应该包含在一个源文件中吗？

The answers to both questions should be “no”. Requiring a module interface declaration to be provided in a file distinct from the implementation file, while in general sound advice, is too constraining a requirement to accommodate all C++ libraries and programs. It should be possible for a module author to provide a single source file containing both the module interface and implementations \(of both exported and non-exported entities\) have the compiler automatically generate the appropriate information containing exported declarations.

这两个问题的答案都应该是“否”。要求在一个与实现文件不同的文件中提供模块接口声明，虽然在一般情况下是合理的建议，但对于容纳所有C++库和程序的需求来说，这样的要求太拘束了。模块作者可以提供一个源文件，其中包含模块接口和实现（导出实体和非导出实体），编译器可以自动生成包含导出声明的适当信息。

Similarly, requiring both interface and implementation to be contained in the same file is too constraining and misses sound engineering practice. Furthermore, we would like to support the scenario where a single module interface is provided, but several independent implementations are made available and the selection of the actual implementation needed to make up a program is left to the user.

类似地，要求接口和实现都包含在同一个文件中，这同样太过限制了，并且忽略了合理的工程实践。此外，我们希望支持这样一种场景：提供了单个模块接口，但是提供了几个独立的实现，而组成程序所需的实际实现的选择则留给用户。

#### 5.2.1 Syntax

A module publishes its external entry points through exported declarations of the form

一个模块通过如下形式的导出声明来发布自己的导出入口

> export _toplevel-declaration_

or

> export { _toplevel-declaration-seq_ }

The braces in this context do not introduce a scope, they are used only for grouping purposes. A toplevel-declaration is either an import declaration \(see §5.3\), a module-export declaration, or an ordinary declaration. An import declaration states that all declarations exported by the nominated module are made available \(e.g. the names are available\) to the importing translation unit. A module-export declaration in the exported section means that the names exported by the nominated module are transitively accessible to any consumer \(e.g. importing translation unit\) of the current module.

在此上下文中，大括号**不引入作用域**，它们仅用于分组。最顶层的声明可以是导入声明（参见§5.3）、模块导出声明或普通声明。导入声明声明了被指定模块导出的所有声明，对当前编译单元来说都是可见的（例如，名称是可见的）。导出部分中的模块导出声明意味着指定模块导出的名称对当前模块的任何使用者（例如，导入的编译单元）都是可传递访问的。 ❓ 

{% hint style="warning" %}
**Rule 2** _No export declaration shall mention a non-exported entity, or an entity with internal linkage or no linkage._

**规则2** _导出声明不得提及非导出实体或具有内部链接或无链接的实体。_
{% endhint %}

{% hint style="info" %}
**Note:** An entity may be declared as exported, and later defined without the exported keyword. Such an entity is still considered exported; only the properties that were computed in the export declaration are exported to the module consumers. In particular, a class that is only declared \(but not defined\) in an export declaration appears incomplete to the module’s consumers even if the class is completed later in the same module unit that declares the interface. Similarly a default argument not present in the export declaration is not visible to the module’s consumers. See §5.2.3.

**注：**一个**实体可以声明为导出的，然后在没有导出关键字的情况下被定义**。这种实体仍然被认为是导出的；只有在导出声明中计算的属性才会被导出到模块使用者。特别地，**在导出声明中仅声明（但未定义）的类对模块的使用者来说是不完整的，即使在声明接口的模块单元后面完成了类** ❓ 。类似地，导出声明中没有出现的默认参数对于模块的使用者是不可见的。参考：§5.2.3。
{% endhint %}

#### 5.2.2 Ownership

Only names exported from a module can be referenced externally to the module. Furthermore, non-exported names cannot be source of ODR violation across two distinct modules; however duplicate definitions in the same module is ill-formed.

只有从模块导出的名称才能从外部引用到模块。此外，**非导出的名称不能成为两个不同模块间ODR冲突的根源**；然而，相同模块中的重复定义是不完整的。

{% code-tabs %}
{% code-tabs-item title="alfa.cxx" %}
```cpp
struct S1 {...};
module Alfa;
struct S2 {...};
export namespace Alfa {
    struct S3 {...};
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

{% code-tabs %}
{% code-tabs-item title="bravo.cxx" %}
```cpp
struct S1 {...};
module Bravo;
struct S2 {...};
export namespace Bravo {
    struct S3 {...};
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

In the example above, modules Alfa and Bravo contributes structure S1 to the global module, and they are subject to the usual ODR constraints. Both of them define their own structures S2 and S3. Despite both Alfa and Bravo defining structure S2, it is possible for another module to import both in the same program.

在上面的例子中，模块Alfa和Bravo向全局模块贡献了结构S1，并且**它们受到通常的ODR约束**。它们都定义了自己的结构S2和S3。尽管Alfa和Bravo都定义了S2结构，但另一个模块可以在同一个程序中导入这两个模块。

#### 5.2.3 Exported Class Properties

An occasionally vexing rule of standard C++ is that of controls access, not visibility. E.g. a private member of a class is visible to, but not accessible to non-member entities. In particular, any change to a private member of a class is likely to trigger re-processing of any translation unit that depends on that class’s definition even if the change does not affect the validity of dependent units. It is tempting to solve that problem with a module system. However, having two distinct sets of rules \(visibility and accessibility\) for class members strikes us as undesirable and potentially fertile source of confusion. Furthermore, we want to support mass-migration of existing codes to modules without programmers having to worry about class member name lookup rules: if you understand those rules today, then you do not have to learn new rules when you move to modules and you do not have to worry about how the classes you consume are provided \(via modules or non-modules\).

标准C++中一个偶尔令人烦恼的规则是访问控制，而不是可见性。比如类的私有成员对非成员实体可见，但对非成员实体不可访问。特别是，对类的私有成员的任何更改都可能触发依赖于类定义的任何转换单元的重新处理，即使更改不会影响依赖单元的有效性。用模块系统解决这个问题是很诱人的。然而，对于类成员来说，拥有两套截然不同的规则（可见性和可访问性）会使我们感到不受欢迎，并且很可能会潜藏一些混乱。此外，我们希望支持大规模迁移现有的代码到新的模块系统，无需程序员担心类成员的名字查找规则：如果今天你理解这些规则，那么当你迁移代码的时候你不需要学习新的规则，你也不需要关心你使用的类是如何被提供的（通过某个模块或非模块）。

That being said, we believe the visibility vs. accessibility issue is a problem that should be solved by an orthogonal language construct, irrespectively of whether a class is defined in a module interface declaration or in an ordinary translation unit. There are proposals \(e.g. “uniform call syntax”\) independently of modules that also need the existing rule to be revisited.

也就是说，我们认为可见性和可访问性问题应该通过一个和现有语法正交的语言概念来解决，无关于一个类是被定义在一个模块接口声明中，还是被定义在一个普通的编译单元里。有些独立于模块的建议（例如“统一调用语法”）也需要重新确认现有的规则。

{% hint style="warning" %}
**Rule 3** _In general, any property of a class \(e.g. completeness\) that is computed in the export declaration part of a module is made available to importing modules as is._

**规则3** _通常，在模块的导出声明部分中计算的类的任何属性（例如完整性）都可以按原样被导入。_
{% endhint %}

That is if a class is declared \(but not defined\) in the interface of a module, then it is seen as an incomplete type by any importing module, even it is defined later in the declaring module in a non-export declaration.

也就是说，如果一个类在模块的接口中声明（但未定义），那么任何导入它的模块都会将其视为不完整类型，哪怕在模块后面的非导出声明中定义了该类。

#### 5.2.4 Should There Be an Interface Section at All? How Many?

It is sensible to imagine a design where a module interface is inferred or collected from definitions that have special marker \(e.g. export\), instead of requiring that the interface be declared at one place. A major downside of that design is that for an import declaration to be useful \(e.g. to effectively consume the module’s interface\), its entirety needs to be produced in a sort of preprocessing phase by some tools that would scan all modules units making up the module. Therefore, it appears that any perceived theoretical benefit is outweighed by that practical implication.

可以合理地设想这样一种设计，即从具有特殊标记（例如导出）的定义中推断或收集模块接口，而不是要求在一个位置声明接口。这种设计的一个主要缺点是，为了使导入声明能够使用（例如，有效地使用模块的接口），它的整体需要在某种预处理阶段由一些工具生成，这些工具将扫描组成模块的所有模块单元。因此，似乎任何感觉上的理论利益都被实际意义所压倒。

#### 5.2.5 Should a Module Interface Be Closed?

For practical reasons similar to those exposed in §5.2.4, we require a module interface to be declared “once for all” at a unique place. This does not preclude extensions of a module. Indeed submodules \(see §5.5\) can be used to extend modules through composition and/or module-export declaration of submodules.

出于类似在§5.2.4中讨论出的实际的原因，我们需要在一个单独的位置声明一个被称为“一劳永逸的（once for all）”模块接口。这并不会影响到模块的扩展。事实上子模块（见§5.5）可以通过组合及/或子模块导出声明来扩展模块。

#### 5.2.6 Alternate Syntax for Module Interface

Several suggestions have been made as alternatives to the currently proposed syntax. In particular, it was observed that if the interface section should immediately follow a module declaration, then both could be combined into a single declaration. That is, instead of writing

我们为目前提议的语法提出了不少的建议作为替代方案。特别要指出的是，如果接口部分应该紧跟模块声明之后，那么这两个部分都可以组合成一个单独的声明。也就是说，如下的写法

```cpp
module M;
export {
    int f(int);
    double g(double, int);
}
```

 one could simply write 可以被简单地写为

```cpp
module M {
    int f(int);
    double g(double, int);
}
```

we considered this but eventually rejected this notation since it is too close to classes and namespaces \(seen as good by some\) but is deceptive in that modules do not introduce any scope of their own – see §4.3. That syntax was also part of the ~~oiginal~~ original module suggestion by Daveed Vandevoorde, but met resistance \[6, §5.11.2\]. Furthermore, export declarations and non-export declarations can be freely mixed.

我们考虑过这个方案，但最终还是拒绝了这种写法，因为它看起来和类，还有命名空间太类似了（一些人觉得挺好），而具有欺骗性的是，模块并没有为自己所有的声明或定义引入任何作用域 —— 见§4.3。这种语法是由Daveed Vandevoorde提出的原本模块建议的一部分，但遇到了不少阻力 \[6, §5.11.2\]。此外，导出声明和非导出声明可以相互自由混合。

We also avoided reusing the access spcifiers public, private to delimit _visibility_ boundaries in a module.

我们同时在避免重用访问说明符`public`，`private`来为模块划定_可见性_范围。

### 5.3 Import Declaration

A translation unit makes uses of names exported by other modules through import declarations:

编译单元通过导入声明使用其他模块导出的名称：

> import _module-name_ ;

An import declaration can appear only at the global scope. It has the effect of making available to the importing translation unit all names exported from the nominated module. Any class completely defined along with all its members are made visible to the importing module. An incomplete class declaration in the export of a module \(even if later completed in that module unit\) is exported as incomplete.

导入声明只能出现在全局作用域内。它的作用是使导入了指定模块的编译单元可以使用从其导出的所有名称。任何完全定义的类及其所有成员都对导入了它的模块可见。导出模块中不完整的类声明（即使稍后在模块单元中被完整定义了）被导出为不完整的。

{% hint style="info" %}
**Note:** An alternate syntax for module importation that avoids a third keyword could be

**注：**避免引入第三个关键字的模块导入替代语法可以是

> using module _module-name_ ;

but the semantics of transitive exports might not be obvious from the notation.

但是从符号来看传递导出的语义可能不够明显。
{% endhint %}

### 5.4 Visibility and Ownership

Consider the following two translation units: 考虑如下两个编译单元：

{% code-tabs %}
{% code-tabs-item title="m1.cc" %}
```cpp
module M1;
export int f(int, int);
// not exported, local to M1
int g(int x) {
    return x * x;
}
// definition of f exported by M1
int f(int x, int y) {
    return g(x) + g(y);
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

{% code-tabs %}
{% code-tabs-item title="m2.cc" %}
```cpp
module M2;
export bool g(int, int);
import std.math;
// not exported, local to M2
int f(int x, int y) {
    return x + y;
}
// definition of g exported by M2
int g(int x, int y) {
    return f(abs(x), abs(y));
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

where module M1 defines and exports a symbol f\(int,int\), defines but does not export symbol g\(int\); conversely, module M2 defines and exports symbol g\(int,int\) defines but does not export symbol f\(int,int\). It is possible to build a program out of M1 and M2

模块M1定义并导出符号`f(int,int)`，定义但不导出符号`g(int)`；相反，模块M2定义并导出符号`g(int,int)`定义但不导出符号`f(int,int)`。可以用M1和M2构建一个程序

{% code-tabs %}
{% code-tabs-item title="main.cc" %}
```cpp
import M1;
import M2;
int main() {
    return f(3,4) + g(3,4);
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

without ODR violation because each non-exported symbol is owned by the containing module.

没有ODR冲突，因为每个非导出的符号都由包含的模块所有。

### 5.5 Submodules

It is frequent for a component to consist of several relatively independent subcomponents. For example, the standard library is made out of a few components: core runtime support \(part of any freestanding implementation\), the container and algorithm library \(commonly referred to as the STL\), the mighty IO streams library, etc. Furthermore each of these components may be subdivided into smaller subcomponents. For example, the container library may be divided into sequence containers, associative containers, unordered containers, etc.

组件通常由几个相对独立的子组件组成。例如，标准库由几个组件组成：核心运行时支持（任何独立实现的一部分）、容器和算法库（通常称为STL）、强大的IO流库等等。此外，每个组件都可以细分为更小的子组件。例如，容器库可以分为顺序容器、关联容器、无序容器等。

We propose a hierarchical naming of modules as a mechanism to support submodules, and extensions of modules by submodules. A submodule is in every aspect a module in its own right. As such, it has an interface and constituent module units, and may itself contain submodules. For example, a module named std.vector is considered a submodule of a module named std. The one distinctive property of a submodule is that its name is only accessible to modules that have access to its parent, provided it is explicitly exported by the parent module.

我们提出了一种分层命名模块的机制，以支持子模块和通过子模块扩展模块。子模块本身就是一个模块。因此，它具有接口和组成它的模块单元，并且其本身也可能包含子模块。例如，一个名为std.vector的模块被认为是一个名为std的模块的子模块。子模块的一个独特特性是，只要它是由父模块显式导出的，只有能够访问它的父模块的模块才能访问它的名称。

A submodule can serve as cluster of translation units sharing implementation detail information \(within a module\) that is not meant to be accessible to outside consumers of the parent module.

子模块可以用作一个在编译单元之间共享实现细节信息（在同一个模块中）的集群，这并不意味着这些信息对父模块的外部使用者来说是可以访问的。

### 5.6 Aggregation

The current design supports expression of components that are essentially aggregates of other components. Here is an example of standard sequence containers component:

当前的设计方案支持表达本质上是其他组件聚合的组件。以下是标准序列容器组件的例子：

{% code-tabs %}
{% code-tabs-item title="Standard sequence container module" %}
```cpp
module std.sequence;
export {
    module std.vector;
    module std.list;
    module std.array;
    module std.deque;
    module std.forward_list;
    module std.queue;
    module std.stack;
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Note that module aggregates are different from submodules in that there is no relationship between the name of a module aggregate and modules it exports. The two notions are not mutually exclusive. For example, the module std.sequence as shown above is both a submodule of std and an aggregate module.

注意，模块聚合不同于子模块，因为模块聚合的名称和导出模块之间没有关系。这两个概念并不是互斥的。例如，上面所示的模块std.sequence既是std的子模块，又是聚合模块。

### 5.7 Global Module

To unify the existing compilation model with the proposed module system, we postulate the existence of a global module containing all declarations that do not appear inside any module \(the case for all C++ programs and libraries in the premodule era.\) Only names with external linkage from the global module are accessible across translation units.

为了将现有的编译模型与所提议的模块系统统一起来，我们假设存在一个全局模块，其中包含不出现在任何模块中的所有声明（适用于“预模块”时代的所有C++程序和库）。只有来自全局模块的外部链接的名称才能跨编译单元访问。

> _这里是为了通过“全局模块”的假设来包装全局命名空间里的所有声明，用于过渡“预模块”时代？_

### 5.8 Module Ownership and ODR

As concluded in §4.5, a module has ownership of all declarations it contains. So, just about how much ownership is it?

作为§4.5中得出的结论，一个模块具有它所包含的所有声明的所有权。那么，它到底有多少所有权呢？

Does a module definition implicitly establish a namespace? No, a module definition does not establish any namespace; and no particular syntax is needed to access a name made visible by an import declaration. All exported symbols belong to the namespace in which they are declared. In particular, the definition of a namespace can span several modules. In the following example,

模块定义是否隐式地建立命名空间？不，模块定义不建立任何命名空间；而且不需要特殊的语法来访问由导入声明而可见的名称。所有导出的符号都属于声明它们的命名空间。特别是，命名空间的定义可以跨越几个模块。在下面的例子里，

{% code-tabs %}
{% code-tabs-item title="parsing.cxx" %}
```cpp
module Syntax;
export namespace Calc {
    class Ast {
        // ...
    };
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

{% code-tabs %}
{% code-tabs-item title="vm.cxx" %}
```cpp
module Evaluator;
import Syntax;
// use Ast from module Syntax
namespace Calc {
    int eval(const Calc::Ast*);
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

the name `Calc` in the modules `Syntax` and `Evaluator` refers to the same namespace. The parameter type of the function `eval` involves the type `Calc::Ast` defined and exported by module `Syntax`.

在模块`Syntax`和`Evaluator`中，名称`Calc`引用了相同的命名空间。函数`eval`的参数类型涉及到模块`Syntax`定义和导出的类型`Calc::Ast`。

{% hint style="info" %}
**Note:** It is not possible for a translation unit to provide a declaration for an entity that it does not own. That is, a translation unit cannot use “`extern`” declaration to claim a matching declaration for an entity \(with external linkage\) declared in a different module unit. This restriction does not apply to entities in the global module \(§5.7\).

**注：**编译单元不可能为它并不持有的实体提供声明。也就是说，编译单元不能使用“`extern`”来要求一个与在不同的模块单元中声明的具有外部链接的实体相匹配的声明。这一限制并不适用于在全局模块中的实体（§5.7）。
{% endhint %}

### 5.9 Constexpr and Inline Functions

We propose no fundamental change to the rules governing constexpr or inline functions. Any exported constexpr or inline function must be defined in the module unit providing the interface of the owning module. The definition itself need not be exported.

我们不建议对constexpr或内联函数的规则进行根本更改。任何导出的constexpr或内联函数都必须在提供接口的所属模块单元中定义。定义本身不需要被导出。 ❓ 

### 5.10 Templates

Standard C++’s compilation model of templates relies on copy-and-paste of their definitions in each translation unit that needs their instantiations. With the module ownership principle, each exported declaration of a template is made available to importing translation units. As ever the two-phase name lookup applies whether a template definition is exported or not.

标准C++的模板编译模型依赖于在每个需要实例化的编译单元中复制和粘贴它们的定义。有了模块所有权原则，每个导出的模板声明都可以用于导入编译单元。无论是否导出模板定义，两段式名称查找（ two-phase name lookup）都将适用。

#### 5.10.1 Definitions

Definitions for templates listed in a module interface are subject to constraints similar to those for inline functions. Furthermore, a class template that is only declared \(but not defined\) in an export declaration is seen as an incomplete class template by importing translation units.

模块接口中列出的模板定义受到与内联函数类似的约束。此外，仅在导出声明中声明（但未定义）的类模板被导入编译单元视为不完整的类模板。 ❓ 

#### 5.10.2 Explicit Instantiations

An explicit instantiation is exported when it appears in an export declaration. The semantics is that the definition resulting from that instantiation is globally available to all importing translation units. For example, given the module

在导出声明中出现的显式实例化会被导出。其语义是：对所有导入编译单元来说实例化产生的定义是全局可用的。例如，给定模块

{% code-tabs %}
{% code-tabs-item title="vec.cpp" %}
```cpp
module Vector;
export {
    template<typename T> struct Vec {
        // ...
    };
    // Explicit instantiation for commonly used specialization
    template struct Vec<int>;
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

the definition of the class `Vec<int>` is exported to any translation unit that imports `Vector`. This provides a mechanism for template authors to “pre-compute” common instantiations and share them across translation unit. Notice that this has effects similar to a C++11-style extern declaration of a specialization combined with an explicit instantiation in an appropriate translation unit.

类`Vec<int>`的定义被导出到导入了`Vector`的任何编译单元。这为模板作者提供了一种机制来“预计算”公共实例化并跨编译单元共享它们。注意，这类似于C++11风格的，结合了在一个合适的编译单元中显式实例化的特化外部声明（extern declaration）。  
[https://en.cppreference.com/w/cpp/language/class\_template](https://en.cppreference.com/w/cpp/language/class_template)

Conversely, any explicit instantiation not in an export declaration is not exported; therefore the resulting definition is local to the containing translation unit. If a specialization is requested in another translation unit, that would otherwise match the non-exported instantiation, the usual rules for template specializations applies as well as the ODR.

相反，导出声明中没有的任何显式实例化都不会导出；因此，定义的结果是导入模块编译单元的本地定义。如果在另一个编译单元中请求特化，它将与非导出实例化匹配 ❓ ，模板特化的通常规则和ODR一样都是适用的。

